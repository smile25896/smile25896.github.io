[{"title":"[JavaScript] Hoisting 為什麼在宣告前就可以使用？","url":"/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript-Hoisting/","content":"前言如果在學習 JavaScript 之前學習過其他程式語言，應該都會發現 JavaScript 跟其他程式語言的其中一個不同之處：變數和 function 可以在宣告之前使用。\nJavaScript 的 Hoisting 讓我可以在變數和 function 宣告前就使用它們，此篇文章將介紹 Hoisting 是什麼？以及它是如何運作的？如果你也曾對此感到好奇或困惑，請繼續閱讀！\nHoisting 是什麼?在 JavaScript 中，如果我們試著對一個還沒有宣告過的變數取值，會得到以下的錯誤：\nconsole.log(variable); // Uncaught ReferenceError: variable is not defined\n\n但如果我們改成：\nconsole.log(variable); // undefinedvar variable;\n\n發現程式竟然不再報錯了，竟然順利執行且回傳了undefined！\n這種在宣告之前就可以使用變數的情況就叫做「Hoisting 提升」，Hoisting 會把宣告的部分挪到 Scope 的最上方，像是這樣：\nvar variable;console.log(variable); // undefined\n\n\n雖然 Hoisting 看起來挪動了宣告變數的程式碼，實質上程式碼的位置並不會移動，而是是在編譯階段經過處理的達成這種效果的。為了方便講解，我仍然繼續用「宣告變數的程式碼被挪到上方」來稱呼這個行為。\n\n\n要注意的是，僅有「宣告變數」的部分會提升，但 Initialization 初始化（也就是賦值的部分）並不會提升。所以下面的程式印出的仍然是 undefined 而不是 100。\nconsole.log(variable); // undefinedvar variable = 100;\n\n因為 Hoisting 將宣告的程式碼挪到上方，而初始化的部分不動，上面的程式碼可以看作成：\nvar variable;console.log(variable); // undefinedvariable = 100;\n\n只有宣告變數的地方被提升了，賦值的程式碼仍然在 console.log(varaible); 的下一行才執行，所以印出的自然是 undefined。\n除了變數宣告會被提升之外，function 宣告也同樣會被提升，所以我們可以在 function 被宣告之前就呼叫 function。\nhello(); // &quot;Hello World!&quot;function hello() &#123;  console.log(&quot;Hello World!&quot;);&#125;\n\n但是只有 function declaration（函式宣告）會被提升，function expression（函式表達式）是不會被提升的。\n所以剛剛的例子如果寫成 function expression，則會引發錯誤：\nhello(); // Uncaught TypeError: hello is not a functionvar hello = function () &#123;  console.log(&quot;Hello World!&quot;);&#125;;\n\n經過 Hoisting 程式碼看起來像是：\nvar hello;hello(); // Uncaught TypeError: hello is not a functionhello = function () &#123;  console.log(&quot;Hello World!&quot;);&#125;;\n\n因為只有宣告會被提升，在呼叫hello()的時候，hello還不是一個 function，因此發生了錯誤。\nFunction 內的 Hoisting了解了 Hoisting 的基本定義與原理之後，我們再接著看 function 內的 hoisting 的運作。\n之前宣告的變數都是在 function 外，宣告會被提升到 global scope 的最上面。而 function 內宣告的變數則會提升到 function scope 的最上面 。\nfunction callName() &#123;  console.log(name);  var name = &quot;Yuju&quot;;&#125;callName(); // undefined\n\n將宣告變數的地方提升到 function scope 的最上面，經過 hoisting 我們可以看成是：\nfunction callName() &#123;  var name;  console.log(name);  name = &quot;Yuju&quot;;&#125;callName(); // undefined\n\n\n接著看下一個例子：\nfunction callName(name) &#123;  console.log(name);&#125;callName(&quot;Yerin&quot;); // &quot;Yerin&quot;\n\n這個程式碼雖然沒有很明確的用一行 var name; 來宣告變數，但參數本身也可以看成是一個宣告變數的過程，加上把參數傳進去的過程，我們可以想像成：\nfunction callName(name) &#123;  var name;  name = &quot;Yerin&quot;;  console.log(name);&#125;callName(&quot;Yerin&quot;); // &quot;Yerin&quot;\n\n\n再來我們看一個變化題：\nfunction callName(name) &#123;  console.log(name);  var name = &quot;Sowon&quot;;&#125;callName(&quot;Yerin&quot;); // &quot;Yerin&quot;\n\n按照之前說的，將宣告變數的程式碼挪到上面，name = &quot;Sowon&quot;; 仍留在原地，如下：\nfunction callName(name) &#123;  var name;  var name;  name = &quot;Yerin&quot;;  console.log(name);  name = &quot;Sowon&quot;;&#125;callName(&quot;Yerin&quot;); // &quot;Yerin&quot;\n\n雖然 name = &quot;Sowon&quot;; 在 console.log(name); 之後，但參數傳進來時本身就賦值了，所以印出的會是&quot;Yerin&quot;而不是undefined，也不是 &quot;Sowon:。\nFunction 宣告與變數宣告的優先權如果有 function 和變數同名，function 的優先權比較高，如果有多個 function\b 重名，後面的 function 會取代前面的 function。\nconsole.log(hello); // fn hello()&#123;&#125;function hello() &#123;&#125;var hello;\n\nconsole.log(hello); // ƒ hello() &#123;console.log(&quot;hello&quot;)&#125;function hello() &#123;&#125;function hello() &#123;  console.log(&quot;hello&quot;);&#125;var hello;\n\nlet 和 const 的 Hoisting在寫這篇文章之前，我一直以為使用 let 和 const 宣告的變數，並不會被提升。我們在執行以下程式碼的時候，也會發現變數看起來並沒有被提升而引發了報錯：\nconsole.log(a); // Uncaught ReferenceError: variable is not definedlet a;\n\n但事實上並非如此，使用 let 和 const 宣告的變數一樣會被提升到 scope 的最上面，只是和用 var 宣告的變數不一樣，使用 let 和 const 宣告的變數並未被初始化（Initialization），所以在賦值之前並不能使用。\n我們可以透過下面的程式碼來佐證：\nvar name = &quot;SinB&quot;;function hello() &#123;  console.log(name);  let name;&#125;hello();\n\n我們推演一下 let 不會被提升的情況， let name; 宣告在 console.log(name) 之後且我們假設不會被提升，所以照理來說第三行的 console.log(name); 應該會存取到第一行的 var name = &quot;SinB;&quot; 而印出 &quot;SinB&quot;。\n但實際上系統會報出 \bUncaught ReferenceError: Cannot access &#39;name&#39; before initialization的錯誤訊息。\n所以實際上，let 和 const 宣告的變數也是會被提升的，只是在賦值之前我們不能使用它，才會有看起來不會被提升的錯覺。\nTemporal dead zone（暫時死區）在 let 和 const 宣告的變數之後、賦值之前，變數不可取用的那個期間，我們稱作 Temporal dead zone，簡稱 TDZ。如果在 TDZ 的期間存取變數，則會發生 ReferenceError 的錯誤。\nfunction hello() &#123;  // 變數 gender 的 TDZ 開始  let name = &quot;Umji&quot;;  console.log(name);  console.log(gender); // 仍在 TDZ 期間所以發生 ReferenceError 錯誤  let gender = &quot;female&quot;; // 變數 gender 的 TDZ 結束&#125;hello(); // Uncaught ReferenceError: Cannot access &#x27;gender&#x27; before initialization\n\nfunction 中的預設參數也會有 TDZ：\nfunction hello(a = b, b = &quot;Eunha&quot;) &#123;&#125;hello(); // Uncaught ReferenceError: Cannot access &#x27;b&#x27; before initialization\n\n因為在變數 b 的 TDZ 期間嘗試取值所以發生了錯誤。\nTypeof在 JavaScript 中，我們可以使用 Typeof 來檢查變數是否被宣告。\n所以在下面程式碼的情況下，雖然我們沒有宣告過 a，但只會回傳 undefined 而不會發生錯誤。\nconsole.log(typeof a); // undefined\n\n第二個例子，變數宣告會被提升到上方，但賦值的程式碼仍維持在下方，程式一樣是回傳 undefined：\nconsole.log(typeof a); // undefinedvar a = &quot;apple&quot;;\n\n如果改成使用 let 宣告，則會因為在 TDZ 的期間引發錯誤：\n// 變數 a 的 TDZ 開始console.log(typeof a); // 仍在 TDZ 期間所以發生 ReferenceError 錯誤let a = &quot;apple&quot;; // 變數 a 的 TDZ 結束\n\nHoisting 的用途\n在宣告之前取用變數但這其實不是一個好的習慣，雖然有 Hoisting 但我們仍要避免在宣告變數前取用變數。甚至我們應該盡量使用 let 與 const，而不是用 var 來宣告變數。\n在 function 宣告之前呼叫 function這點來說幫助就非常大了，很多時候我們習慣把 function 宣告放在下方。\n讓 function 可以互相呼叫如果 function 之間沒辦法呼叫，function 互相呼叫程式就沒辦法執行：\n\nfunction add(a, b) &#123;  check(++a, ++b);&#125;function check(a, b) &#123;  if (a + b &lt; 10) &#123;    add(a, b);  &#125; else &#123;    console.log(a, b);  &#125;&#125;add(0, 0);\n\n總結先簡單做個重點整理：\n\nvar 宣告會被提升。\nInitialization 的部分不會被提升。\nlet 和 const 雖然會被提升，但賦值之前無法取值。\nfunction declaration 會被提升，而 function expression 不會。\nfunction 與變數同名，function 優先。\n\n在寫這篇文章之前，我對 Hoisting 的認識只有「用 var 宣告會提升，而用 let 和 const 不會提升。」這樣粗淺的認識。\n仔細研究之後，才發現 Hoisting 的運作其實大有文章，有非常多的細節在其中，比我原本想像中的複雜許多。\n經過一番瞭解與消化後，才整理出這篇文章，希望對正在讀這篇文章的你有幫助。第一次打一篇比較正式的 js 文章，如果有任何錯誤，也煩請指正，謝謝。\n\n參考資料：\n\n\nMDN: Hoisting\nUnderstanding Hoisting in JavaScript\nWhat is Hoisting in JavaScript?\n我知道你懂 hoisting，可是你了解到多深？\n\n","categories":["前端","JavaScript"],"tags":["Javascript"]},{"title":"[CSS] Box Model 盒子模型","url":"/%E5%89%8D%E7%AB%AF/CSS/css-box-model/","content":"Box Model 是 CSS 很重要的一個基礎觀念。\n什麼是 Box Model？每個 HTML 元素可以說是都一個盒子，這個盒子由四個構造組成的，由內而外分別是： Content ( 內容 )、Padding ( 內邊距 )、Border ( 邊框 ) 和 Margin ( 外邊距 )。\n\nContent：顯示文字和圖像的區域。\nPadding：Content 和 Border 之間的填充區域。\nBorder：邊框\nMargin：與其他盒子的距離。\n\n如下圖所示：\n\n圖片來源：w3schools\n\n一般來說我們會把 Content 、 Padding 和 Border 當作元素本身，而 Margin 則是元素與其他元素的距離。\nMargin 的特性\n永遠是透明的\n對於 inline 元素，垂直方向的 margin 沒有作用，只能設定水平方向。\n值可以設定成：&lt;length&gt;、&lt;pecentage&gt;或auto\n值若設定百分比(%)，百分比的參考準則為父元素的寬度。很容易搞混的是：margin-top 和 margin-top 也是參考父元素的寬度。\n值若設定 auto ，對於margin-left和margin-left來說，等於「剩餘空間」的意思。代表若我設定 margin-left: auto; margin-right: 0; 則代表右邊的外邊距為零，左邊則會補足剩餘空間，也就是向右靠齊的效果。若兩邊都設定成 auto，如：margin-left: auto; margin-right: auto; 則代表左右兩邊會平均分配剩餘空間，也就是水平置中的效果。對於margin-top和margin-bottom來說，設值為auto等於 0。\n可以有負值。\n\nPadding 的特性\n背景色依據元素的background設定。\n對於 inline 元素，垂直方向的 margin 沒有作用，只能設定水平方向。\n值可以設定成：&lt;length&gt;或&lt;pecentage&gt;\n值若設定百分比(%)，百分比的參考準則為父元素的寬度。同 margin 屬性相同：padding-top 和 padding-top 也是參考父元素的寬度。\n不能有負值。\n\nBorder 的特性可設定三種屬性：\n\nborder-width：寬度\nborder-color：顏色\nborder-style：樣式\n\n","categories":["前端","CSS"],"tags":["CSS"]},{"title":"[CSS100] Day 01 Hello World","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss01/","content":"Hello World Demo\n  See the Pen \n  100DaysCss #01 by Cathy (@smile25896)\n  on CodePen.\n\n\n\nCSS 100天挑戰的第一天，因為是第一天基本上沒有什麼特別難的地方。用div畫出「100」的圖案，簡單排版下方的字，最後加上漸層背景就能完成了。本系列的文章不會手把手的詳細紀錄整個程式碼撰寫過程與說明，只會簡單筆記用到的語法與技巧。\n學習重點\n畫出「100」的字樣圖案\n線性漸層：linear-gradient\n\n畫出「100」的字樣圖案「1」斜的和豎的兩筆畫分別由兩個div組合而成的，斜的部分透過transform: rotate(50deg)讓它旋轉就能達成斜的效果，再透過絕對定位調整位置，就能組合成一個1。另外為了讓「1」看起來不那麼銳利，設定border-radius: 3px讓它有圓角。\n.one1&#123;  height: 40px;  width: 20px;  transform: rotate(50deg);  position: absolute;  top: 0;  left: -10px;&#125;.one2&#123;  height: 100px;  width: 22px;  position: absolute;  top: 0px;  left: 7px;  z-index: 3;&#125;.one1,.one2&#123;  background: #fff;  border-radius: 3px;&#125;\n\n「0」的部分是用div透過border-radius: 50%畫一個圓，中心不填色只填邊框的顏色，就可以畫成一個空心的圓。\n.zero1,.zero2&#123;  height: 100px;  width: 100px;  box-sizing: border-box;  border: 22px solid #fff;  border-radius: 50%;&#125;\n\n\n線性漸層：linear-gradient漸層其實分很多種，線性漸層、放射狀漸層等等，本次要介紹的linear-gradient是線性漸層，顧名思義就是往單一個方向直線做漸變的就叫做線性漸層。\n最簡單的寫法：\nbackground: linear-gradient(red, blue);\n\n因為沒有指定方向，預設由上到下\n\n\n若要改成從左到右可以寫成下面兩種寫法：\nbackground: linear-gradient(to right, red, blue);background: linear-gradient(90deg, red, blue);\n\n\n\n也可以調整顏色的起始位置：\nbackground: linear-gradient(90deg, red 50%, blue 100%);\n\n紅色的起始位置從50%的位置開始，所以左半邊的部分全部都是紅色，漸層的部分只從中間到右邊而已。\n\n\n想要再增加一個顏色的話，只要在參數在增加一個顏色就可以了：\nbackground: linear-gradient(90deg, red, blue, black);\n\n因為沒有設定顏色的起始位置，所以會平均分配。\n\n\n漸層的學問其實很大，除了本次介紹的線性漸層以外，css還提供了許多其他漸層的語法，可以參考深入理解 CSS 漸層 ( CSS Gradient )。\n另外漸層的色彩模式也有很多種，像是Lab、Lch、HSL、RGB，CSS原生的漸層是採用RGB的漸層方法，在顏色的過度區常常會有混濁髒髒的感覺，其實還有很多很美的漸層。詳細可以參考視覺上的完美漸層（Chromatic）這篇文章。\n\n\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 02 Menu Icon","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss02/","content":"Menu Icon Demo\n  See the Pen \n  100DaysCss #02 #plus by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的題目主要練習的是CSS動畫，讓一個按鈕點下去透過transform: translate() rotate()做出位移和旋轉的動畫。比較難的是動畫的加速function，用到了關於貝茲曲線cubic-bezier的屬性。\n學習重點\n製作動畫：animation 和 keyframes\n貝茲曲線：cubic-bezier\n\n製作動畫：animation 和 keyframeskeyframeskeyframes為關鍵影格，可以設定在某個時間點的css狀態。\n例如下面這個範例，則設定開頭時rotate為0deg，結束時rotate為90deg。\n@keyframes rotate &#123;  /* 開頭 */  from &#123;    transform: rotate(0deg);  &#125;  /* 結尾 */  to &#123;    transform: rotate(90deg);  &#125;&#125;\n\n也可以依據時間的百分比設定，如下：\n@keyframes rotate2 &#123;  0% &#123;    transform: rotate(0deg);  &#125;  50% &#123;    transform: rotate(360deg);  &#125;  100% &#123;    transform: rotate(0deg);  &#125;&#125;\n\nanimation接著只要將關鍵影格套入到css的animation屬性中，就可以讓目標轉動\ndiv&#123;  animation-name: rotate;  animation-duration: 2s;  animation-iteration-count: infinite;&#125;\n\nanimation有相當多的屬性可以調整\n\n\n\n屬性名稱\n說明\n預設值\n其他設定值\n\n\n\nanimation-name\n關鍵影格的名稱。\n\n\n\n\nanimation-duration\n動畫播放一次週期的時間。\n0\n\n\n\nanimation-timing-function\n動畫的加速函式。\nease\nlinear、ease-in…\n\n\nanimation-delay\n動畫延遲開始的時間。\n0\n\n\n\nanimation-iteration-count\n動畫播放的次數\n1\ninfinite：無限\n\n\nanimation-direction\n動畫播放的方向\nnormal\n\n\n\nanimation-fill-mode\n動畫播放前後的模式\nnone\n\n\n\nanimation-play-state\n動畫播放的狀態\nrunning\npaused\n\n\n完整說明可以參考這裡\n也能寫成縮寫：\nanimation:name duration | timing-function | delay | iteration-count | direction | fill-mode | play-state;\n\n本題應用本題的上下兩條線以及中間的線，做的事情不太一樣\n上下兩條線動畫可以拆解成兩個部分，\n\n透過transform: translate();將上下兩條線位移至中間\n再用transform: rotate();旋轉線條\n\n將這兩個部分各分配50%的動畫時間，keyframes如下：\n@keyframes animate-line-1 &#123;  0% &#123;    transform: translate(0, 0px);  &#125;  50% &#123;    transform: translate(0, 23px) rotate(0);  &#125;  100% &#123;    transform: translate(0, 23px) rotate(315deg);  &#125;&#125;@keyframes animate-line-3 &#123;  0% &#123;    transform: translate(0, 0px);  &#125;  50% &#123;    transform: translate(0, -23px) rotate(0);  &#125;  100% &#123;    transform: translate(0, -23px) rotate(225deg);  &#125;&#125;\n\n而中間那條線不需要位移和旋轉，單純透過transform: scale();讓他變小後消失，另外在調整透明度讓它消失得更自然一點，keyframes如下：\n@keyframes animate-line-2 &#123;  0% &#123;    transform: scale(1);    opacity: 1;  &#125;  100% &#123;    transform: scale(0);    opacity: 0;  &#125;&#125;\n\n由「X」變回「三」的動畫則是反過來就好了，不另贅述。\n貝茲曲線：cubic-bezieranimation-timing-function剛剛介紹的animation-timing-function動畫加速函式，如果沒有設定的話預設是ease，在動畫開頭先用比較緩和速度執行，之後漸漸加快直到動畫結尾再慢慢降下速度。視覺上會有「慢-快-慢」的效果。\n如果要讓「三」變成「X」時有快到慢的效果，而反過來當「X」變回「三」時則有慢到快的效果時，最簡單的方式是設定ease-out（漸出）與ease-in（漸入）。\nanimation-timing-function完整的說明及參數可以參考這裡\ncubic-bezier若希望動畫的速度變化比ease-out、ease-in更強烈的話，就可以透過cubic-bezier手動設定動畫的加速度函式。animation-timing-function預設的幾種加速函式畫成貝茲曲線圖會是這個樣子：\n貝茲曲線有兩個控制點，調整控制點的位置則可以讓我們畫出曲線cubic-bezier(x1, y1, x2, y2)：四個參數分別是(控制點1的x軸, 控制點1的y軸, 控制點2的x軸, 控制點2的y軸)若不清楚控制點是什麼的人，建議可以到cubic-bezier.com上玩玩看會更了解。\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 03 The Pyramid","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss03/","content":"The Pyramid Demo\n  See the Pen \n  100DaysCss #03 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的金字塔和金字塔的陰影的三角形不是以往學到的透過border畫出來的，而是透過clip-path這個屬性畫成的，透過這個屬性不只三角形，各式各樣的圖形感覺都能畫得出來！再搭配Day2學到的動畫，改變一下天空、金字塔的顏色以及太陽和陰影的角度，就能夠完成。另外雖然範例沒有，但我還加了黃昏時候的橘黃色感覺。\n學習重點\nclip-path\n\nclip-pathclip-path是利用剪裁遮罩，建立可視區域，可視區域外的地方皆被隱藏，透過clip-path產生的剪裁遮罩來產生各式各樣圖形。clip-path有非常多種用法：\nclip-path: circle();    // 圓型clip-path: ellipse();   // 橢圓型clip-path: polygon();   // 多邊形\n\n其中三角形就是使用polygon()，參數分別對應到多邊形點的xy軸，所以幾個參數就代表有幾個點。\n直角三角形：\nclip-path: polygon(0 0, 0% 100%, 100% 100%);\n\n\n或是任意調整點的位置：\nclip-path: polygon(50% 0%, 0 100%, 94% 63%);\n\n\n除了三角形也可以畫更多邊形，像是八邊形：\nclip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);\n\n\n\n還可以做一些其他的形狀，像是：\nclip-path: polygon(20% 0%, 0% 20%, 30% 50%, 0% 80%, 20% 100%, 50% 70%, 80% 100%, 100% 80%, 70% 50%, 100% 20%, 80% 0%, 50% 30%);\n\n\n有興趣的話可以到CSS clip-path maker上操作看看。\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 04 Loading","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss04/","content":"Loading Demo\n  See the Pen \n  100DaysCss #04 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n原本的題目是圓形，我自己換成了三角形並加了旋轉的效果。這個題目比較像之前的綜合練習，三個三角形各有一點時間差，最大的三角形最早變大但最晚變小，相反最小的三角形則是最晚變大最早變小。另外一個細節就是，當三角形放得越大時，陰影就越擴散，形成三角形越大的時候，視覺上越靠近自己。另外因為我改成了三角形一般的box-shadow沒辦法使用，要改成用filter: drop-shadow()製作陰影。\n學習重點\n陰影：filter: drop-shadow()\n動畫製作\n\n陰影：filter: drop-shadow()一般陰影常用box-shadow這個屬性，但box-shadow只能做出方形的陰影，並不會針對實際的形狀做出對應形狀的陰影。\n像是這樣：\nbox-shadow: 2px 2px 6px rgba(0,0,0,0.7);\n\n\n\n但filter: drop-shadow()只會針對非透明的部分做陰影，就可以做出三角形的陰影。\nfilter: drop-shadow(5px 5px 2px rgba(0,0,0,0.7));\n\n\n\n\n動畫製作這三個三角形依序變大之後，再返向縮小回去，因此我們只要建立好放大的動畫，再使用animation-direction: alternate;讓動畫在執行完一次後，反向再執行一次。（加速函式也會跟著反過來）\n接著先來寫最大的三角形的關鍵影格：\n@keyframes circle1-animate&#123;  0%&#123;    filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.2));    transform: scale(0) rotate(0deg);  &#125;  100% &#123;    filter: drop-shadow(10px 10px 15px rgba(0,0,0,0.3));    transform: scale(1) rotate(120deg);  &#125;&#125;\n這樣就會有一個會不停邊放大邊旋轉之後又邊縮小邊旋轉的三角形動畫，另外想讓三角形縮小至不見之後，隔了一小段時間才再次出現，因此調整一下關鍵影格，讓三角形0%~30%的時間都維持在scale(0)的狀態。\n@keyframes circle1-animate&#123;  0%, 30%&#123;    filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.2));    transform: scale(0) rotate(0deg);  &#125;  100% &#123;    filter: drop-shadow(10px 10px 15px rgba(0,0,0,0.3));    transform: scale(1) rotate(120deg);  &#125;&#125;\n\n中型的三角形要在大三角形出現之後才出現，因此設定他的關鍵影格0%~50%的時間都維持在scale(0)的狀態，最小的則是0%~70%的時間都維持在scale(0)的狀態，其他皆與大三角形相同。\n接著將關鍵影格套用至animation屬性中，透過之前學到的cubic-bezier設定加速函式，讓動畫在正向播放時呈現「快-慢」的效果，alternate倒轉時也會將加速函式倒過來變成「慢-快」。\n.circle1&#123;  animation: circle1-animate 2s cubic-bezier(.21,.98,.6,.99) infinite alternate;&#125;\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 09 Weather","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss09/","content":"Weather Demo\n  See the Pen \n  100DaysCss #08 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的題目不難，大致上可以分成兩個重點Sass的語法學習和雨滴動畫。雨滴的造型只要用到偽元素就能簡單達成，而雨滴降落的動畫對於我來說，更像一個數學習題，要調整雨滴降落的時間與延遲的速度，才能讓雨滴降落顯得自然。\n學習重點\nSass for迴圈\nSass @extend\n雨滴製作\n雨滴落下的動畫\n\nscss for迴圈Sass裡有迴圈的用法，如下：\n@for $i from 1 through 10 &#123;  .drop-big-#&#123;$i&#125; &#123;    left: 40 * $i + px;    animation-delay: ( random(25)/10 ) + s;    animation-duration: ( random(10)/20+0.6 ) + s;  &#125;&#125;\n\nscss @extendSass裡也有繼承的用法\n.circle &#123;  width: 10px;  height: 10px;  border-radius: 50%;  background: red;&#125;.circle-big &#123;  @extend .square  width: 30px;  height: 30px;&#125;\n轉成css會變成：\n.circle, .circle-big &#123;  width: 10px;  height: 10px;  border-radius: 50%;  background: red;&#125;.circle-big &#123;  width: 30px;  height: 30px;&#125;\n\nscss甚至可以寫成以下，也有同樣的效果\n.circle &#123;  width: 10px;  height: 10px;  border-radius: 50%;  background: red;  &amp;-big &#123;    @extend .square    width: 30px;    height: 30px;  &#125;&#125;\n\n雨滴製作雨滴是由一個圓形+三角形(before偽元素)組合成的，原本想直接讓整個雨滴透過transform: rotate()轉向。但因為雨滴落到地上時，要有一個扁掉的效果，扁掉的效果我透過transform: scale(1.5, 0.5)達成，但若整個雨滴透過transform: rotate()轉過方向，則扁掉的地方不會水平。因此，我只旋轉了三角形的部分並調整位置，達到斜斜的雨滴效果。\n$drop-color: #7FC1F9;.drop&#123;  position: absolute;  top: -10px;  left: 300px;  width: 10px;  height: 10px;  border-radius: 50%;  background: $drop-color;  animation: down 1.2s linear 0s infinite;  &amp;:before&#123;    content: &#x27;&#x27;;    display: block;    position: relative;    top: -5px;    left: 2px;    width: 0;    height: 0;    border-style: solid;    border-width: 0 5px 10px 5px;    border-color: transparent transparent $drop-color transparent;    transform: rotate(20deg);  &#125;&#125;\n\n雨滴落下的動畫讓雨滴落下的關鍵影格其實不難，可以拆解成 1.雨滴往左下方移動(0%~90%) 和 2.在最低點時扁掉(90%~100%) 這兩個部分。\n@keyframes down &#123;\t0% &#123;\t\ttransform: rotate(0deg) translate(0, 0);\t&#125;\t90% &#123;\t\ttransform: rotate(0deg) translate(-80px, 314px) scale(1, 1);\t&#125;\t100% &#123;\t\ttransform: rotate(0deg) translate(-80px, 314px) scale(1.5, 0.5);\t&#125;&#125;\n\n要讓雨滴落的自然，要靠animation-delay和animation-duration去調整，讓雨掉落的時間與速率都稍微錯開。另外一個細節就是，近的（大的）雨滴要落得比較快，遠的（小的）雨滴要落得比較慢才會自然。\n@for $i from 1 through 10 &#123;  .drop-big-#&#123;$i&#125; &#123;    animation-delay: ( random(25)/10 ) + s;    animation-duration: ( random(10)/20+0.6 ) + s;  &#125;&#125;","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 08 Metaballs","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss08/","content":"Metaballs Demo\n  See the Pen \n  100DaysCss #08 by Cathy (@smile25896)\n  on CodePen.\n\n\n\nMetaballs是一個我覺得很神奇的題目，也因為覺得有趣稍微做了點變化和調整，成品和當初的題目其實不太一樣，其實不太知道我自己改版過後的版本還能不能叫Metaballs。以下只重點紀錄這次新學到的語法或用法。\n學習重點\nSlim\nfilter: contrast() 和 filter: blur()\n\nMetaballs中文叫做元球或變形，指兩個球體靠在一起時，會有下圖變形的情況。（圖片來源：維基百科）\nSlim這是我第一次接觸Slim，應該算是html的模板語言。有點像可以用程式邏輯的方式寫html。\n.box  - for i in (1..3)    div class&#x3D;&quot;item-#&#123; i &#125;&quot;\n\n會轉成以下html\n&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;item-1&quot;&gt;  &lt;div class=&quot;item-2&quot;&gt;  &lt;div class=&quot;item-3&quot;&gt;  &lt;div class=&quot;item-4&quot;&gt;&lt;/div&gt;\n把原本的div省略直接寫class名稱，很多重複的元素可以直接跑for迴圈非常方便，目前只用到for這個功能，以後有接觸到新功能在介紹。\nfilterfilter是css的濾鏡效果，讓Metaballs能有相黏的效果，filter是最重要的一個環節，此練習會用到filter: contrast()和filter: blur();\nfilter: blur()高斯模糊，括號李可以設定要模糊的CSS的長度。\nfilter: contrast()對比度，0就是完全沒對比（會變一片灰色）、100%表示顏色不變、超過100%對比則會越大。\n透過讓他模糊，然後再加強對比，就能達到Metaballs的效果。\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[LeetCode] 1. Two Sum 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode1/","content":"前言菜鳥的刷題記錄，前端工作兩年後發現很多程式基礎（演算法、資料結構等等）都忘得差不多了，其實當初學生時期的底子也不太紮實。手很生，決定開始上 LeedCode 刷題。基本上是希望是一個紀錄菜鳥成長的過程的系列文。\n題目LeetCode 題目連結：https://leetcode.com/problems/two-sum/\n難度等級：Easy\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.\n翻譯：給一個 nums(int array)和 target(int)，找出 nums 陣列中的兩個數值加起來會等於 target，回傳這兩個元素的位置。一定會有唯一解，不會使用相同的元素兩次。\nExample 1:\nInput: nums &#x3D; [2,7,11,15], target &#x3D; 9Output: [0,1]Output: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].\n\nExample 2:\nInput: nums &#x3D; [3,2,4], target &#x3D; 6Output: [1,2]\n\nExample 3:\nInput: nums &#x3D; [3,3], target &#x3D; 6Output: [0,1]\n\n解題過程做法：很單純的跑兩個迴圈，第二個迴圈只從第一個數之後的數開始跑，若兩數相加等於零即為答案。\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123;  for (let i = 0; i &lt; nums.length; i++) &#123;    for (let j = i + 1; j &lt; nums.length; j++) &#123;      if (nums[j] + nums[i] === target) &#123;        return [i, j];      &#125;    &#125;  &#125;&#125;;\n\n成績Runtime: 76 ms (排名：83.53%)Memory Usage: 38.7 MB (排名：73.70%)\n心得LeetCode 的第一題，單純解出答案不要求效率的話，基本上沒有什麼難度，算是很溫和的試水溫題。\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 13. Roman to Integer","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode13/","content":"題目難度：Easy\nLeetCode 連結：https://leetcode.com/problems/roman-to-integer/\nRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer.\n題目有點長，簡單來說就是要把羅馬符號數字轉換成阿拉伯數字。\n解題過程羅馬數字有一個特徵：\n1.當羅馬符號的數值呈現降冪時，只要把每個羅馬符號數值加總就是答案。Example 1:\nInput: s &#x3D; &quot;III&quot;Output: 3Explanation: 為降冪排列：I&#x3D;1，1 + 1 + 1 &#x3D; 3\n\nExample 2:\nInput: s &#x3D; &quot;LVIII&quot;Output: 58Explanation: 為降冪排列：L &#x3D; 50, V &#x3D; 5, III &#x3D; 3，50 + 5 + 3 &#x3D; 58\n\n2.當數值比較小的羅馬符號出現在左邊時，該數值會加上一個負號。\nExample 3:\nInput: s &#x3D; &quot;MCMXCIV&quot;Output: 1994Explanation: M &#x3D; 1000, C &#x3D; 100, X &#x3D; 10, V &#x3D; 5, I &#x3D;1.M &#x3D; 1000C 出現在比他大的M(1000)左邊 &#x3D; -100M &#x3D; 1000X 出現在比他大的C(100)左邊 &#x3D; -10C &#x3D; 100I 出現在比他大的V(5)左邊 &#x3D; -1V &#x3D; 51000 - 100 + 1000 - 10 + 100 - 1 + 5 &#x3D; 1994\n\n所以我們只需判斷 n+1 比 n 大還是小，就能判斷 n 的正負值。\n程式：/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123;    const roman = &#123;        I: 1,        V: 5,        X: 10,        L: 50,        C: 100,        D: 500,        M: 1000    &#125;    let sum = 0    for(let i=0; i&lt;s.length-1; i++)&#123;        if(roman[s[i]] &gt;= roman[s[i+1]])&#123;            sum += roman[s[i]];        &#125;        else&#123;            sum -= roman[s[i]];        &#125;    &#125;    sum += roman[s[s.length-1]];    return sum&#125;;\n\n複雜度時間複雜度：O(N)空間複雜度：O(1)\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 198. House Robber 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode198/","content":"題目LeetCode 連結：https://leetcode.com/problems/house-robber/\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n你是一個小偷。你打算偷一整條街的房子。每一間房子都有錢可以偷，但如果偷了兩間相鄰的房子，就會觸發警報系統引來警察，導致你被逮補。\n題目會提供一個數字 array，array 的值代表每一間房子可以偷盜的錢，在不驚動警報系統的前提，要怎麼偷才能偷到最多的錢呢？\nExample 1:\nInput: nums &#x3D; [1,2,3,1]Output: 4Explanation: 1 + 3 &#x3D; 4.\n\nExample 2:\nInput: nums &#x3D; [2,7,9,3,1]Output: 12Explanation: 2 + 9 + 1 &#x3D; 12.\n\n解題過程\n陣列 nums 紀錄每個房子的錢，我們還需要一個紀錄一個目前房子可以偷到的最大值的陣列 m。\n只有第一間房子的時候，只有第一間可以偷。所以最大值 m[0] 為 nums[0]。\n當有兩間房子的時候，因為不能偷相鄰的房子，兩間挑一間比較多錢的偷。m[1] = Max(nums[0],nums[1])。\n當有 n 間房子的時候，若選擇了這間房子，則不能去偷上一間房子，所以要在「上一間房子的最大值」和「上上間房子的最大值+這間房子」取大值。Max(m[n-1], m[n-2]+nums[n])\n\n/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var rob = function(nums) &#123;    // 1. 陣列 nums 紀錄每個房子的錢，我們還需要一個紀錄一個目前房子可以偷到的最大值的陣列 m。    let maxs = [];    // 2. 只有第一間房子的時候，只有第一間可以偷。。    // 3. 當有兩間房子的時候，因為不能偷相鄰的房子，兩間挑一間比較多錢的偷。    maxs[0] = nums[0];    maxs[1] = Math.max(nums[0], nums[1]);    // 當有 n 間房子的時候，若選擇了這間房子，則不能去偷上一間房子，    // 所以要在「上一間房子的最大值」和「上上間房子的最大值+這間房子」取大值。    for(let i=2; i&lt;nums.length; i++)&#123;        maxs[i] = Math.max(maxs[i-1], maxs[i-2]+nums[i]);    &#125;    return maxs[maxs.length-1];&#125;;\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 2. Add Two Numbers 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode2/","content":"題目LeetCode 題目連結：https://leetcode.com/problems/add-two-numbers/\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n輸入兩個不為空的 linked lists 代表兩個為非負數的整數，這些數字以反方向儲存，每一個 node 包含一個數字，將兩數相加，並回傳總和的 linked lists。\nExample 1:\nInput: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]Output: [7,0,8]Explanation: 342 + 465 &#x3D; 807.\n\nExample 2:\nInput: l1 &#x3D; [0], l2 &#x3D; [0]Output: [0]\n\nExample 3:\nInput: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]Output: [8,9,9,9,0,0,0,1]\n\n解題過程做法：\n將l1和l2的.val相加answers裡，溢位的部分直接將answers.next的值加1，然後將l1和l2移到.next，直到l1和l2皆等於null。\n/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function (l1, l2) &#123;  let answers = new ListNode(0);  let curNode = answers;  let isFirst = true;  while (l1 || l2) &#123;    if (!isFirst) &#123;      if (!curNode.next) &#123;        curNode.next = new ListNode(0);      &#125;      curNode = curNode.next;    &#125; else &#123;      isFirst = false;    &#125;    let sum = curNode.val;    if (l1) &#123;      sum += l1.val;      l1 = l1.next;    &#125;    if (l2) &#123;      sum += l2.val;      l2 = l2.next;    &#125;    if (sum &lt; 10) &#123;      curNode.val = sum;    &#125; else &#123;      curNode.val = sum - 10;      curNode.next = new ListNode(1);    &#125;  &#125;  return answers;&#125;;\n\n成績Runtime: 128 ms (排名：89.43%)Memory Usage: 43.8 MB (排名：85.30%)\n心得很久沒碰 linked lists 了，也沒用 javascript 寫過，一開始一直在想開頭會多一個 0，後來才想到直接回傳.next就可以跳過開頭的 0 了。\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 37. Sudoku Solver 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode37/","content":"題目題目有點長，直接放上 LeetCode 連結：https://leetcode.com/problems/sudoku-solver/\n簡單來說就是要做一個自動產生數獨解答的程式。題目會輸入一個二維陣列，數獨題目空白的地方會用”.”代替，我們則要將數獨的答案填完回傳。\n輸入的數獨題目，一定會有一個唯一解，所以不需要考慮題目有錯誤或是多重解答的情況。\n解題過程\n從第一個空白格開始找可能的數字填上（行列和九宮格皆不重複的數字）\n再找下一個空白格找可能的數字\n如果沒有可以填的數字，則回到上一格填寫的數字，填寫下一個可能的數字。\n如果上一格已經沒有可以填寫的數字了，再回到上上格以此類推。如果有找到可以填寫的數字，則從第 2 步驟繼續往下。\n直到所有空白格都填上數字即完成。\n\n實際程式我使用遞迴的方式，如下：\nfunction solveSudoku(board) &#123;  recurse(board);  return board&#125;function recurse(board) &#123;  for(let row = 0; row &lt; 9; row++)&#123;    for(let col = 0; col &lt; 9; col++)&#123;      // 如果該格為空白，找出可能的數字填上      if(board[row][col] === &quot;.&quot;)&#123;        // 找出所有可能的數字        const possibles = Array.from(&#123;length: 9&#125;, () =&gt; true)        // 刪除相同行列出現過的數字        for(let i=0; i&lt;9; i++)&#123;          if(board[row][i] !== &quot;.&quot;)&#123;            possibles[Number(board[row][i])-1] = false;          &#125;          if(board[i][col] !== &quot;.&quot;)&#123;            possibles[Number(board[i][col])-1] = false;          &#125;        &#125;        // 刪除九宮格中出現過的數字        const blockStart = Math.floor(row/3) * 3;        const blockEnd = Math.floor(col/3) * 3;        for(let k=blockStart; k&lt;blockStart+3; k++) &#123;          for(let l=blockEnd; l&lt;blockEnd+3; l++) &#123;            if(board[k][l] !== &quot;.&quot;)&#123;              possibles[Number(board[k][l])-1] = false;            &#125;          &#125;        &#125;        // 嘗試每個可能的數字        for(let m = 0; m&lt;9; m++)&#123;          if(!possibles[m]) continue;          board[row][col] = (m+1).toString();          // 找下一個數字          if(recurse(board))&#123;            return true;          &#125;          else&#123;            board[row][col] = &quot;.&quot;;          &#125;        &#125;        // 所有數字皆不符合，return false回到上一個數字        return false;      &#125;    &#125;  &#125;  return true;&#125;\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[CSS100] Day 05 Statistic","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss05/","content":"Statistic Demo\n  See the Pen \n  CSS100Days 005 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的題目使用svg畫了折線圖，折線圖上的點透過絕對定位固定位置。\n學習重點\n折線圖製作\n\nhtml部分，使用了svg中的polyline（折線），指定每個點的x,y位置，可以畫出連續的直線。\n&lt;svg&gt;  &lt;polyline points=&quot;9,46 50,12 90,23 130,11 171,38 211,48 251,19&quot;&gt;&lt;/polyline&gt;&lt;/svg&gt;\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[LeetCode] 946. Validate Stack Sequences 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode945/","content":"題目LeetCode 連結：https://leetcode.com/problems/validate-stack-sequences/\nGiven two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.\n題目會給一個 pushed 的數值陣列和一個 popped 的數值陣列。我們需要驗證這兩個陣列是否順序的 push 和 pop 同一個 Stack。\nExample 1:\nInput: pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4),pop() -&gt; 4,push(5),pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n\nExample 2:\nInput: pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2.\n\n解題過程看到題目我第一個想法就是直接透過模擬一個 stack push 和 pop 的過程，來判斷是不是合理的。\n\n建立一個 stack 陣列。\n將 pushed 的數值依序 push 進 stack 中。\n若 stack 中的最後一個值與 popped[0]的值相同，則將 stack 最後一個值 pop 出來，並將 popped 的第一個值移出。\n所有 pushed 的數值都放進 arr 之後，依序驗證 arr 的最後一個值和 popped[0]的值是否相同。如果不相同則回傳 false，相同則將 stack 最後一個值 pop 出來，並將 popped 的第一個值移出。\nstack 的值全部被 pop 出回傳成功。\n\n/** * @param &#123;number[]&#125; pushed * @param &#123;number[]&#125; popped * @return &#123;boolean&#125; */var validateStackSequences = function (pushed, popped) &#123;  let stack = [];  while (pushed.length !== 0) &#123;    if (stack.length &gt; 0 &amp;&amp; stack[stack.length - 1] === popped[0]) &#123;      stack.pop();      popped.shift();    &#125; else &#123;      stack.push(pushed.shift());    &#125;  &#125;  while (popped.length !== 0 &amp;&amp; stack.length !== 0) &#123;    if (stack[stack.length - 1] === popped[0]) &#123;      stack.pop();      popped.shift();    &#125; else &#123;      return false;    &#125;  &#125;  return true;&#125;;\n\n成績Runtime: 67 ms (排名：87.77%)Memory Usage: 43.6 MB (排名：71.89%)\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 7. Reverse Integer 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode7/","content":"題目Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n輸入一個 32-bit 的整數 x，將數字倒過來回傳。如果倒過來的數字超出[-2^31, 2^31 - 1]範圍，則回傳 0。\nExample 1:\nInput: x &#x3D; 123Output: 321\n\nExample 2:\nInput: x &#x3D; -123Output: -321\n\nExample 3:\nInput: x &#x3D; 120Output: 21\n\nExample 4:\nInput: x &#x3D; 0Output: 0\n\n解題過程方法 1基本上是把數字轉成字串，倒著因為負號不需要倒轉，先取絕對值，將 x 轉成字串再返向存入一個新的字串，如果有負號最後把負號加回去。\n/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function (x) &#123;  let xStr = String(Math.abs(x));  let ans = &quot;&quot;;  for (let i = xStr.length - 1; i &gt;= 0; i--) &#123;    ans += xStr[i];  &#125;  ans = Number(ans);  ans = x &gt; 0 ? ans : -ans;  if (ans &gt; Math.pow(2, 31) || ans &lt; -Math.pow(2, 31)) &#123;    return 0;  &#125;  return ans;&#125;;\n\n成績Runtime: 100 ms (排名：58.87%)Memory Usage: 40.5 MB (排名：35.38%)\n方法 2再思考怎麼改善的時候，突然想到或許不一定要用 string，直接用數字存也可以，於是就有了這個方法 2。\n/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function (x) &#123;  let xStr = Math.abs(x);  let ans = 0;  while (xStr &gt;= 10) &#123;    ans += xStr % 10;    ans *= 10;    xStr = parseInt(xStr / 10);  &#125;  ans += xStr;  if (x &lt; 0) &#123;    ans = -ans;  &#125;  if (ans &gt; Math.pow(2, 31) || ans &lt; -Math.pow(2, 31)) &#123;    return 0;  &#125;  return ans;&#125;;\n\n成績小小改善了一點Runtime: 100 ms (排名：58.87%)Memory Usage: 40.3 MB (排名：58.06%)\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 856. Score of Parentheses 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode856/","content":"題目LeetCode 連結：https://leetcode.com/problems/score-of-parentheses/\nGiven a balanced parentheses string s, return the score of the string.\nThe score of a balanced parentheses string is based on the following rule:\n“()” has score 1.AB has score A + B, where A and B are balanced parentheses strings.(A) has score 2 * A, where A is a balanced parentheses string.\n題目會給一個有效的括號字串，代表不會出現)(或是(()這種左右不對等的括號，而我們要將括號依照題目的規則轉換成分數。轉換的規則是：\n\n() = 1\n並排的括號會是「相加」的關係\n括號包住括號會是「乘以 2」的關係\n\nExample\nInput: s &#x3D; &quot;()&quot;Output: 1\n\nExample 2:\nInput: s &#x3D; &quot;(())&quot;Output: 2\n\nExample 3:\nInput: s &#x3D; &quot;()()&quot;Output: 2\n\n解題過程Stack 解法\n每當遇到(時，就在 stack 上 push0\n遇到)則去判斷 stack 的最上層是否是02-1. 若是0則代表這邊是一個()的情況，()代表數值1，因此我們把 stack 中的0 pop 出來，push1進去。2-2. 若不是0代表這組括號之間還有其他的數值，要先把括號裡面的數值加總之後，再將它乘以2。\n最後 stack 裡面會剩下並排關係括號數值，再把 stack 裡面的數值全部相加即是答案\n\n實例演示：Input: (()())()Step1: stack[0]     &#x2F;&#x2F;遇到左括號，stack放入0Step2: stack[0,0]   &#x2F;&#x2F;遇到左括號，stack放入0Step3: stack[0,1]   &#x2F;&#x2F;遇到右括號，與左括號合併成1放回stackStep4: stack[0,1,0] &#x2F;&#x2F;遇到左括號，stack放入0Step5: stack[0,1,1] &#x2F;&#x2F;遇到右括號，與左括號合併成1放回stackStep6: stack[4]     &#x2F;&#x2F;遇到右括號，stack最上方不是0(左括號)                    &#x2F;&#x2F;先把0(左括號)上面的數值相加之後乘以2Step7: stack[4,0]   &#x2F;&#x2F;遇到左括號，stack放入0Step8: stack[4,1]   &#x2F;&#x2F;遇到右括號，與左括號合併成1放回Step9: return 4+1   &#x2F;&#x2F;將stack的數值相加後回傳\n\n程式：/** * @param &#123;string&#125; s * @return &#123;number&#125; */var scoreOfParentheses = function(s) &#123;  let stack = [];    for (let i = 0; i &lt; s.length; i++) &#123;        if (s[i] === &quot;(&quot;) &#123;            stack.push(0);        &#125;        else &#123;            let score = 0;            while (stack[stack.length - 1] !== 0) &#123;                score += stack.pop();            &#125;            stack.pop();            // 如果score=0，代表是()回傳1            // 如果score!=0，代表要將()中間的數值乘以2            // 所以直接取(score * 2, 1)的最大值就好            score = Math.max(score * 2, 1);            stack.push(score);        &#125;    &#125;    let score = 0;    while (stack.length &gt; 0) &#123;        score += stack.pop();    &#125;    ;    return score;&#125;;\n\n而這個的 2-2 將()中間的值相加的這個步驟，可以不用再額外跑一個迴圈，直接在過程中，將數值額外存成一個 tmpScore，只在遇到左括號時將 tmpScore 放入 stack 後歸零。\n實例演示：Input: (()())()Step1: stack[0]     &#x2F;&#x2F;遇到左括號，stack放入0       tmpScore &#x3D; 0Step2: stack[0,0]   &#x2F;&#x2F;遇到左括號，stack放入0       tmpScore &#x3D; 0Step3: stack[0]     &#x2F;&#x2F;遇到右括號，與左括號合併成1存成tmpScore       tmpScore &#x3D; 1Step4: stack[0,1]   &#x2F;&#x2F;遇到左括號，stack放入tmpScore的值       tmpScore &#x3D; 0 &#x2F;&#x2F;並將tmpScore歸零Step5: stack[0]     &#x2F;&#x2F;遇到右括號合成一個1，與並排的數值1相加&#x3D;2       tmpScore &#x3D; 2 &#x2F;&#x2F;將2存到tmpScoreStep6: stack[]     &#x2F;&#x2F;遇到右括號，tmpScore不是0，代表上一個字不是左括號       tmpScore &#x3D; 4 &#x2F;&#x2F;把tmpScore的數值乘以2Step7: stack[4]     &#x2F;&#x2F;遇到左括號，stack放入tmpScore的值       tmpScore &#x3D; 0 &#x2F;&#x2F;將tmpScore歸零Step8: stack[]   &#x2F;&#x2F;遇到右括號合成一個1，再與並排的數值1相加&#x3D;5       tmpScore &#x3D; 5 &#x2F;&#x2F;將tmpScore歸零Step9: return tmpScore\n\n程式：/** * @param &#123;string&#125; s * @return &#123;number&#125; */var scoreOfParentheses = function(s) &#123;    let stack = [];    let tmpScore = 0;    for (let i = 0; i &lt; s.length; i++) &#123;        if (s[i] === &quot;(&quot;) &#123;            stack.push(tmpScore);            tmpScore = 0;        &#125;        else &#123;            tmpScore = stack.pop() + Math.max(tmpScore*2, 1);        &#125;    &#125;    return  tmpScore;&#125;;\n\n複雜度時間複雜度：O(N)空間複雜度：O(N)\n遞迴解法看了討論區的文章之後，發現還有遞迴的解法，又用了遞迴的解法嘗試解了一次。\n因為()和 function 的()太像了，我把實例演示題目的 input 括號改成中括號[];\nfunction Score()case 1: Score([]) 回傳 1case 2: Score([A]) 回傳 Score(A)*2case 3: Score(AB) 回傳 Score(A)+Score(B)\n實例演示：Input: [[][]][]Step1: Score([[][]][])Step2: Score(Score([[][]])+Score([]))Step3: Score(Score([Score([])+Score([])])+1)Step4: Score(Score([1+1])+1)Step5: Score(2*(1+1)+1)Step5: &#x3D; 5\n\n程式：/** * @param &#123;string&#125; s * @return &#123;number&#125; */var scoreOfParentheses = function(s) &#123;    return score(s, 0, s.length-1);&#125;;function score(s, start, end)&#123;  if(start+1 === end)&#123;    return 1;  &#125;  let b = 0, cur = 0;  for(let i=start; i&lt;=end; i++)&#123;    if(s[i]===&quot;(&quot;)&#123;      b++;    &#125;    else&#123;      b--;    &#125;    if(b === 0)&#123;      if(i!==end || start+1===end)&#123;        cur += score(s, start, i)        start = i+1;      &#125;      else&#123;        cur += score(s, start+1, end-1)*2;      &#125;    &#125;  &#125;  return cur;&#125;\n\n複雜度時間複雜度：O(N^2)\n\n()()()…情況時複雜度最低：$O(N)$(((…)))情況時複雜度最高：$O(N^2)$\n空間複雜度：$O(N)$\n\n計算深度解法討論區中，我看到最讓我震驚的解法就是直接計算深度的解法。這是利用四則運算「分配律」的邏輯解的。\n實例演示：Input: (()())()\n\n無論是 stack 還是遞迴的解法，解題的邏輯都是將(()())()轉換成：\n2*(1+1)+1\n\n而計算深度的解法則是將2*(1+1)+1透過分配律轉換成：\n2*1 + 2*1 + 1\n\n因此我們只需判斷每一組()的深度是多少，就知道要乘以2*[深度]倍，就能夠得出答案。\n程式：/** * @param &#123;string&#125; s * @return &#123;number&#125; */var scoreOfParentheses = function(s) &#123;    let b = 0;    let ans = 0;    for(let i=0; i&lt;s.length; i++)&#123;        if(s[i] === &quot;(&quot;)&#123;            b++;        &#125;        else&#123;            b--;            if(s[i-1] === &quot;(&quot;)&#123;                ans += 1 &lt;&lt; b;            &#125;        &#125;    &#125;    return ans;&#125;;\n\n複雜度時間複雜度：O(N)空間複雜度：O(1)\n心得這個問題一開始會想用 stack 解法是因為覺得題目跟四則運算的類型有點像，就直覺用了以前學過的 stack 方法來處理左右括號的問題。寫完之後參考了其他人的解法做了優化版的 stack 方法。\n之後再嘗試用遞迴，最後最最震驚的是，前面兩種做法我一直都被題目框架框住，沒想到這個題目可以先套用分配律將它們拆開計算。\n這次的題目對我來說有點難，stack 和遞迴的兩種方式在想演算法跟實際寫程式時都花了一點時間思考，之後又學習了計算深度的解法，這個題目算是收穫滿滿。\n另外，我發現 LeetCode 上 Runtime 好像怪怪的，同一個程式碼送出兩次的時間會差很多，上網查發現好像是 LeetCode 上 js 的 Runtime 計算會有問題。所以之後的文章都拿掉這個區塊，改成紀錄時間複雜度與空間複雜度。\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[JavaScript] Scope 作用域是什麼？","url":"/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript-Scope-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/","content":"Scope 是什麼？Scope 中文翻作「作用域/範疇…\b」代表了變數可以被取用的範圍，如果嘗試在 scope 外存取變數，就會發生錯誤。\n下面的範例就是因為在 localText 的 scope 外存取 localText ，所以發生了錯誤。\nfunction hello() &#123;  var localText = &quot;Hello Function!&quot;;&#125;console.log(localText); // Uncaught ReferenceError: localText is not defined\n\n那麼 Scope 的範圍有哪幾種呢？\n\nGlobal Scope：在任何地方都能存取此變數。\nFunction Scope：在 function 內部能存取此變數。\nBlock Scope：在 block{}內部能存取此變數。\nModule Scope：\n\n向外找的特性知道變數的 Scope 範圍，有助於幫我們判斷現在存取的變數究竟是誰。\n在區域範圍內時，可以讀到自己區域的變數以及外面區域的變數，但全域的地方無法讀到區域的變數。\n\n為了幫助理解以下的程式，在這邊先知道用 var 宣告的變數，若在 function 外宣告，作用域為 global；在 function 內宣告，作用域在 function 內。後面會有更詳細的介紹。\n\n看一下這個範例：\nvar globalVariable = &quot;G&quot;; // 作用域為全域function test() &#123;  var localVariable = &quot;L&quot;; // 作用域在 test() 內  console.log(globalVariable); // &quot;G&quot;&#125;test();console.log(localVariable); // Uncaught ReferenceError: localVariable is not defined\n\n在 test() 內可以讀到外面的 globalVariable ，但 global 區域沒辦法讀到 test() 內的變數，因此會報錯。\n所以簡單來說在存取變數的時候，會先在區域內找這個變數，如果找不到再向外面一層找。\n\n如果變數有重名的情況，會先在小區域找，找不到的話才會再往外找：\nvar username = &quot;Cathy&quot;; // 作用域為全域function callName() &#123;  var username = &quot;Winni&quot;; // 作用域在 callName() 裡面  console.log(username); // &quot;Winni&quot;&#125;callName();console.log(username); // &quot;Cathy&quot;\n\n第一個 console.log 在 callName() 內找得到 username 這個變數，所以印出 &quot;Winni&quot;。\n第二個 console.log 在 callName() 外面，不會往 callName 內讀取變數，所以他印出外面的全域變數 &quot;Cathy&quot; 。\n\n如果有多個 function 也是一樣，會先在小區域找，找不到的話再往外找：\nvar username = &quot;Cathy&quot;; // 作用域為全域function callName() &#123;  var username = &quot;Winni&quot;; // 作用域在 callName() 裡面  function test() &#123;    console.log(username); // &quot;Winni&quot;;  &#125;  test();&#125;callName();\n\n這個範例，test() 裡面找不到 username ，所以向外一層在 callName() 中找到了，印出 Winni。\n\n接下來出一個小題目，讓大家自己判斷一下 console.log 會印出什麼呢？\nvar username = &quot;Cathy&quot;; // 作用域為全域function callName() &#123;  var username = &quot;Winni&quot;; // 作用域在 callName() 裡面  function test() &#123;    var username = &quot;Joy&quot;; // 作用域在 test() 裡面    console.log(username);  &#125;  test();&#125;callName();\n\n.....答案是：&quot;Joy&quot;\n因為 test() function 本身就找得到 username，所以印出來的就是宣告在 test() 裡的 username，其值為 &quot;Joy&quot;。\n\n第二題小測驗\nvar username = &quot;Cathy&quot;; // 作用域為全域function callName() &#123;  var username = &quot;Winni&quot;; // 作用域在 callName() 裡面  console.log(username);&#125;username = &quot;Frank&quot;;callName();\n\n.....答案是：&quot;Winni&quot;\n第六行修改的 username 為全域變數的 username，而非宣告在 callName() 裡的 username，所以 callName() 裡的 username 值不會改變。\n而 console.log 在 call() 中找得到 username ，所以會印出 Winni。\n\n第三題小測驗\nvar username = &quot;Cathy&quot;; // 作用域為全域function callName() &#123;  username = &quot;Winni&quot;;&#125;callName();console.log(username);\n\n.....答案是：Winni\ncallName() 中找不到 username ，所以他向外一層找到了全域作用域的 username ，並將其值修改成 Winni，因此 console.log 印出來的值為被修改過的 Winni。\n從上面幾個範例，只要我們知道變數的作用域是哪裡，就能判斷存取的變數究竟是哪個變數了。\n但是，我們要怎麼知道變數的作用域是哪裡呢？\n用 var 宣告變數如果在 function 外用 var 宣告的變數，那麼該變數就是的 scope 是 global，在任何地方都能存取。\nvar group = &quot;GFRIEND&quot;; // 作用域為全域console.log(group); // &quot;GFRIEND&quot;if (group) &#123;  console.log(group); // &quot;GFRIEND&quot;&#125;function getName() &#123;  console.log(group); // &quot;GFRIEND&quot;&#125;\n\n\n如果在 function 內用 var 宣告的變數，那麼該變數的 scope 是 function，在 function 內部才能存取。\nfunction getName() &#123;  var group = &quot;VIVIZ&quot;;  console.log(group); // &quot;VIVIZ&quot;&#125;getName();console.log(group); // Uncaught ReferenceError: group is not defined\n\n第二個 console.log 因為無法讀取到 function 內部宣告的變數，所以會報錯。\nFunction Scope 的問題問題一：範圍太大，可能無意間造成覆蓋。\nfunction test() &#123;  var count = 20;  if (count &gt; 0) &#123;    var count = 0;    console.log(count); // 0  &#125;  console.log(count); // 0&#125;test();\n\n雖然上面的程式碼看起來是宣告了兩個變數，但因為是在同一個 function scope 內宣告兩次 count 變數，因此兩個變數實際上是同一個變數，在修改 if 裡面的 count 值時，外面的 count 同時也被修改了。\n這顯然不太符合我們的預期。\n問題二：\nfor (var i = 0; i &lt; 5; i++) &#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;\n\n正常我們應該預期結果要印出 1,2,3,4,5，但實際上會印出 5,5,5,5,5。\n因為我們以為，程式是這樣運作的：\nfor (...)&#123;  setTimeout(() =&gt; &#123;    console.log(1);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(2);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(3);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(4);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(5);  &#125;, 5000);&#125;\n\n但實際上卻是：\nfor (...)&#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;for (...)&#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;\n\n因為 i 這個變數不在 function 裡面宣告，所以是 global 範圍的變數。當 setTimeout() function 倒數完一秒要印出 i 時， 是迴圈跑完的時候， i 的值已經變成了 5。\n諸如此類的問題，讓我們使用起來有些不便，到了 ES6 之後，新增了 block scope 的概念。\n用 let 和 const 宣告的變數在 ES6 版本，有了新的宣告變數的方式： let 和 const，使用這兩種方式會以 block 來區分作用域的範圍，也就是用 &#123;&#125; 來區分的意思。\n在 block 之外使用 let 和 const 宣告的變數，如同在 function 外使用 var 宣告的變數一樣，都是 global scope 的，在任何地方都能使用。\nlet count = 1;if (count &gt; 0) &#123;  console.log(count); // 1&#125;function test() &#123;  console.log(count);&#125;test(); // 1\n\n\n在 block 內用 let 和 const 宣告的變數，scope 為 block 內部。\n修改 &#123;&#125; 內的 name ，並不會影響到外面的 name ：\nlet name = &quot;John&quot;;&#123;  let name = &quot;Kevin&quot;;  console.log(name); // &quot;Aden&quot;&#125;console.log(name); // &quot;Kevin&quot;\n\n\n更常的情況，我們會應用在 if 判斷式或是 for 等迴圈裡。\n\n判斷是和迴圈的括號也算在 block 的範圍內，像是 for(let i=0; i&lt;10; i++)&#123;&#125; 的 i 。\n\nblock 內用 let 宣告的變數，不會影響到 block 外的變數。\nlet count = 1;if (count &gt; 0) &#123;  let count = 0;  console.log(count); // 0&#125;console.log(count); // 1\n\n\n在同一個 block scope 用 let 或 const 重複宣告變數的話，會發生錯誤：\nif (count &gt; 0) &#123;  let count = 0;  console.log(count); // 0  let count = 1; // Uncaught SyntaxError: Identifier &#x27;count&#x27; has already been declared&#125;\n\n\n如果是在迴圈裡用 let 或 const 宣告變數的話，每一次迴圈的是一次新的 block scope。\n所以在迴圈裡宣告變數，並不會算重複宣告變數：\nfor (var i = 0; i &lt; 5; i++) &#123;  let count = 0;  console.log(count);&#125;\n\n會印出五次 0 。\n\n也可以解決上面用 var 宣告的問題二，原本的程式是這樣：\nfor (var i = 0; i &lt; 2; i++) &#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;\n\n會印出 2,2\n但我們改成用 let 宣告的話，就可以正常印出 0, 1：\nfor (let i = 0; i &lt; 2; i++) &#123;  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;\n\n這個例子我其實理解了很久才懂，因為每一次迴圈都是新的 block scope，所以 i 的值並不會被修改到。\n迴圈跑第一次的時候程式看起來像是這樣：\nfor (...) &#123;  let i = 0; // 第一次迴圈，所以 i 拿到 for 條件裡設定的 0 。  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);  i++;&#125;\n\n第二次則會變成：\nfor (...) &#123;  let i = 1; // 第二次迴圈，所以依據條件上一次迴圈最後 i 的值 。  setTimeout(() =&gt; &#123;    console.log(i);  &#125;, 5000);&#125;\n\n兩次迴圈的 i，是獨立互不相干擾的變數，所以就能正常的印出 1, 2。\n靜態作用域在討論靜態作用域之前，大家先來思考一下，在哪裡呼叫 function，會不會影響到變數的值？\n我們看下面這個範例：\nvar name = &quot;Cathy&quot;;function callName &#123;  console.log(name);&#125;function test()&#123;  var name = &quot;Winni&quot;;  callName();&#125;test();\n\n我們在 callName() 裡面找不到 name 變數，所以要向外一層找找看有沒有 name。\n那麼這個外面一層，究竟是定義 function 時的外面 —— 也就是 global 區域，還是呼叫 function 時的外面 —— 也就是 test() 區域呢？\n答案是 global 區域，所以 console.log(name) 印出來應為 &quot;Cathy&quot; 。\n因為在撰寫時變數的作用域就已經確定好了，所以稱之為「靜態作用域」。\n總結關於 scope 這個主題，原本處於一個大概知道在做什麼的了解，但仔細要寫起來，也發現了一些原本沒有注意到的細節。像是「靜態作用域」就是在寫這篇文章時，第一次學到的知識。\n這篇文章來來回回改了很多遍，因為總是會有沒有先講Ａ介紹Ｂ的時候會不清楚，但沒有先講Ｂ介紹Ａ也會有點模糊等雞生蛋蛋生雞的問題，希望我最後呈現的內容能讓人好懂。\n","categories":["前端","JavaScript"],"tags":["Javascript"]},{"title":"[CSS100] Day 10 Watch","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss10-Watch/","content":"Watch Demo\n  See the Pen \n  100DaysCss #10 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n繼上一次[CSS100] Day 05 Statistic用過 SVG 之後，這次不停繞圈圈的圓也要用到 SVG。另外繞圈圈的效果還新學到了stroke-dasharray和stroke-dashoffset這兩個屬性。\n學習重點\n用 svg 製作一個空心的圓\n製作繞圈的效果：stroke-dasharray和stroke-dashoffset\n\n用 svg 製作一個空心的圓html 部分，使用了 svg 中的circle，cx和cy分別代表圓心 x 軸與 y 軸的位置，r則代表了圓的半徑。因此可以透過下面的 html，畫出一個圓\n&lt;svg class=&quot;spinner&quot; viewBox=&quot;0 0 202 202&quot; xlmns=&quot;https://www.w3.org/2000/svg&quot;&gt;  &lt;circle cx=&quot;101&quot; cy=&quot;101&quot; r=&quot;99.5&quot;&gt;&lt;/circle&gt;&lt;/svg&gt;\n\n接著要透過 css 將這個圓調整成空心的圓：\ncircle &#123;  stroke: #f85b5b; // 邊框顏色  stroke-width: 3; // 邊框寬度  fill: none; // 填充顏色：無&#125;\n\n\n\n詳細的 SVG 教學，我覺得可以參考ooxx 的教學介紹得相當詳盡。\n製作繞圈的效果（stroke-dasharray 和 stroke-dashoffset）stroke-dasharray是用來畫虛線的屬性，可以讓stroke一段實線一段空白一段實線一段空白的效果。直接用 MDN 上的範例來說明：\n&lt;svg viewBox=&quot;0 0 30 10&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;  &lt;!-- 沒有虛線 --&gt;  &lt;line x1=&quot;0&quot; y1=&quot;1&quot; x2=&quot;30&quot; y2=&quot;1&quot; stroke=&quot;black&quot; /&gt;  &lt;!-- 線段和空白的長度相同 --&gt;  &lt;line x1=&quot;0&quot; y1=&quot;3&quot; x2=&quot;30&quot; y2=&quot;3&quot; stroke=&quot;black&quot; stroke-dasharray=&quot;4&quot; /&gt;  &lt;!-- 線段長度4，空白長度1 --&gt;  &lt;line x1=&quot;0&quot; y1=&quot;5&quot; x2=&quot;30&quot; y2=&quot;5&quot; stroke=&quot;black&quot; stroke-dasharray=&quot;4 1&quot; /&gt;  &lt;!-- 若設定奇數：線段4 空白1 線段2 空白4 線段1 空白2不斷循環 --&gt;  &lt;line x1=&quot;0&quot; y1=&quot;7&quot; x2=&quot;30&quot; y2=&quot;7&quot; stroke=&quot;black&quot; stroke-dasharray=&quot;4 1 2&quot; /&gt;  &lt;!-- 若設定偶數線段和空白的長度就會是固定的 --&gt;  &lt;line    x1=&quot;0&quot;    y1=&quot;9&quot;    x2=&quot;30&quot;    y2=&quot;9&quot;    stroke=&quot;black&quot;    stroke-dasharray=&quot;4 1 2 3&quot;  /&gt;&lt;/svg&gt;\n\n呈現的效果：\nstroke-dashoffset可以將用stroke-dasharray畫出的虛線向後推移。\n製作繞圈的效果認識完上面兩個屬性，只要將stroke-dasharray的長度設超過圓的周長，再控制stroke-dashoffset將他推移，就能完成繞圈的效果。\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]}]