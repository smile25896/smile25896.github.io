[{"title":"[CSS100] Day 02 Menu Icon","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss02/","content":"Menu Icon Demo\n  See the Pen \n  100DaysCss #02 #plus by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的題目主要練習的是CSS動畫，讓一個按鈕點下去透過transform: translate() rotate()做出位移和旋轉的動畫。比較難的是動畫的加速function，用到了關於貝茲曲線cubic-bezier的屬性。\n學習重點\n製作動畫：animation 和 keyframes\n貝茲曲線：cubic-bezier\n\n製作動畫：animation 和 keyframeskeyframeskeyframes為關鍵影格，可以設定在某個時間點的css狀態。\n例如下面這個範例，則設定開頭時rotate為0deg，結束時rotate為90deg。\n@keyframes rotate &#123;  /* 開頭 */  from &#123;    transform: rotate(0deg);  &#125;  /* 結尾 */  to &#123;    transform: rotate(90deg);  &#125;&#125;\n\n也可以依據時間的百分比設定，如下：\n@keyframes rotate2 &#123;  0% &#123;    transform: rotate(0deg);  &#125;  50% &#123;    transform: rotate(360deg);  &#125;  100% &#123;    transform: rotate(0deg);  &#125;&#125;\n\nanimation接著只要將關鍵影格套入到css的animation屬性中，就可以讓目標轉動\ndiv&#123;  animation-name: rotate;  animation-duration: 2s;  animation-iteration-count: infinite;&#125;\n\nanimation有相當多的屬性可以調整\n\n\n\n屬性名稱\n說明\n預設值\n其他設定值\n\n\n\nanimation-name\n關鍵影格的名稱。\n\n\n\n\nanimation-duration\n動畫播放一次週期的時間。\n0\n\n\n\nanimation-timing-function\n動畫的加速函式。\nease\nlinear、ease-in…\n\n\nanimation-delay\n動畫延遲開始的時間。\n0\n\n\n\nanimation-iteration-count\n動畫播放的次數\n1\ninfinite：無限\n\n\nanimation-direction\n動畫播放的方向\nnormal\n\n\n\nanimation-fill-mode\n動畫播放前後的模式\nnone\n\n\n\nanimation-play-state\n動畫播放的狀態\nrunning\npaused\n\n\n完整說明可以參考這裡\n也能寫成縮寫：\nanimation:name duration | timing-function | delay | iteration-count | direction | fill-mode | play-state;\n\n本題應用本題的上下兩條線以及中間的線，做的事情不太一樣\n上下兩條線動畫可以拆解成兩個部分，\n\n透過transform: translate();將上下兩條線位移至中間\n再用transform: rotate();旋轉線條\n\n將這兩個部分各分配50%的動畫時間，keyframes如下：\n@keyframes animate-line-1 &#123;  0% &#123;    transform: translate(0, 0px);  &#125;  50% &#123;    transform: translate(0, 23px) rotate(0);  &#125;  100% &#123;    transform: translate(0, 23px) rotate(315deg);  &#125;&#125;@keyframes animate-line-3 &#123;  0% &#123;    transform: translate(0, 0px);  &#125;  50% &#123;    transform: translate(0, -23px) rotate(0);  &#125;  100% &#123;    transform: translate(0, -23px) rotate(225deg);  &#125;&#125;\n\n而中間那條線不需要位移和旋轉，單純透過transform: scale();讓他變小後消失，另外在調整透明度讓它消失得更自然一點，keyframes如下：\n@keyframes animate-line-2 &#123;  0% &#123;    transform: scale(1);    opacity: 1;  &#125;  100% &#123;    transform: scale(0);    opacity: 0;  &#125;&#125;\n\n由「X」變回「三」的動畫則是反過來就好了，不另贅述。\n貝茲曲線：cubic-bezieranimation-timing-function剛剛介紹的animation-timing-function動畫加速函式，如果沒有設定的話預設是ease，在動畫開頭先用比較緩和速度執行，之後漸漸加快直到動畫結尾再慢慢降下速度。視覺上會有「慢-快-慢」的效果。\n如果要讓「三」變成「X」時有快到慢的效果，而反過來當「X」變回「三」時則有慢到快的效果時，最簡單的方式是設定ease-out（漸出）與ease-in（漸入）。\nanimation-timing-function完整的說明及參數可以參考這裡\ncubic-bezier若希望動畫的速度變化比ease-out、ease-in更強烈的話，就可以透過cubic-bezier手動設定動畫的加速度函式。animation-timing-function預設的幾種加速函式畫成貝茲曲線圖會是這個樣子：\n貝茲曲線有兩個控制點，調整控制點的位置則可以讓我們畫出曲線cubic-bezier(x1, y1, x2, y2)：四個參數分別是(控制點1的x軸, 控制點1的y軸, 控制點2的x軸, 控制點2的y軸)若不清楚控制點是什麼的人，建議可以到cubic-bezier.com上玩玩看會更了解。\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 04 Loading","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss04/","content":"Loading Demo\n  See the Pen \n  100DaysCss #04 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n原本的題目是圓形，我自己換成了三角形並加了旋轉的效果。這個題目比較像之前的綜合練習，三個三角形各有一點時間差，最大的三角形最早變大但最晚變小，相反最小的三角形則是最晚變大最早變小。另外一個細節就是，當三角形放得越大時，陰影就越擴散，形成三角形越大的時候，視覺上越靠近自己。另外因為我改成了三角形一般的box-shadow沒辦法使用，要改成用filter: drop-shadow()製作陰影。\n學習重點\n陰影：filter: drop-shadow()\n動畫製作\n\n陰影：filter: drop-shadow()一般陰影常用box-shadow這個屬性，但box-shadow只能做出方形的陰影，並不會針對實際的形狀做出對應形狀的陰影。\n像是這樣：\nbox-shadow: 2px 2px 6px rgba(0,0,0,0.7);\n\n\n\n但filter: drop-shadow()只會針對非透明的部分做陰影，就可以做出三角形的陰影。\nfilter: drop-shadow(5px 5px 2px rgba(0,0,0,0.7));\n\n\n\n\n動畫製作這三個三角形依序變大之後，再返向縮小回去，因此我們只要建立好放大的動畫，再使用animation-direction: alternate;讓動畫在執行完一次後，反向再執行一次。（加速函式也會跟著反過來）\n接著先來寫最大的三角形的關鍵影格：\n@keyframes circle1-animate&#123;  0%&#123;    filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.2));    transform: scale(0) rotate(0deg);  &#125;  100% &#123;    filter: drop-shadow(10px 10px 15px rgba(0,0,0,0.3));    transform: scale(1) rotate(120deg);  &#125;&#125;\n這樣就會有一個會不停邊放大邊旋轉之後又邊縮小邊旋轉的三角形動畫，另外想讓三角形縮小至不見之後，隔了一小段時間才再次出現，因此調整一下關鍵影格，讓三角形0%~30%的時間都維持在scale(0)的狀態。\n@keyframes circle1-animate&#123;  0%, 30%&#123;    filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.2));    transform: scale(0) rotate(0deg);  &#125;  100% &#123;    filter: drop-shadow(10px 10px 15px rgba(0,0,0,0.3));    transform: scale(1) rotate(120deg);  &#125;&#125;\n\n中型的三角形要在大三角形出現之後才出現，因此設定他的關鍵影格0%~50%的時間都維持在scale(0)的狀態，最小的則是0%~70%的時間都維持在scale(0)的狀態，其他皆與大三角形相同。\n接著將關鍵影格套用至animation屬性中，透過之前學到的cubic-bezier設定加速函式，讓動畫在正向播放時呈現「快-慢」的效果，alternate倒轉時也會將加速函式倒過來變成「慢-快」。\n.circle1&#123;  animation: circle1-animate 2s cubic-bezier(.21,.98,.6,.99) infinite alternate;&#125;\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 03 The Pyramid","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss03/","content":"The Pyramid Demo\n  See the Pen \n  100DaysCss #03 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的金字塔和金字塔的陰影的三角形不是以往學到的透過border畫出來的，而是透過clip-path這個屬性畫成的，透過這個屬性不只三角形，各式各樣的圖形感覺都能畫得出來！再搭配Day2學到的動畫，改變一下天空、金字塔的顏色以及太陽和陰影的角度，就能夠完成。另外雖然範例沒有，但我還加了黃昏時候的橘黃色感覺。\n學習重點\nclip-path\n\nclip-pathclip-path是利用剪裁遮罩，建立可視區域，可視區域外的地方皆被隱藏，透過clip-path產生的剪裁遮罩來產生各式各樣圖形。clip-path有非常多種用法：\nclip-path: circle();    // 圓型clip-path: ellipse();   // 橢圓型clip-path: polygon();   // 多邊形\n\n其中三角形就是使用polygon()，參數分別對應到多邊形點的xy軸，所以幾個參數就代表有幾個點。\n直角三角形：\nclip-path: polygon(0 0, 0% 100%, 100% 100%);\n\n\n或是任意調整點的位置：\nclip-path: polygon(50% 0%, 0 100%, 94% 63%);\n\n\n除了三角形也可以畫更多邊形，像是八邊形：\nclip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);\n\n\n\n還可以做一些其他的形狀，像是：\nclip-path: polygon(20% 0%, 0% 20%, 30% 50%, 0% 80%, 20% 100%, 50% 70%, 80% 100%, 100% 80%, 70% 50%, 100% 20%, 80% 0%, 50% 30%);\n\n\n有興趣的話可以到CSS clip-path maker上操作看看。\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 05 Statistic","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss05/","content":"Statistic Demo\n  See the Pen \n  CSS100Days 005 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的題目使用svg畫了折線圖，折線圖上的點透過絕對定位固定位置。\n學習重點\n折線圖製作\n\nhtml部分，使用了svg中的polyline（折線），指定每個點的x,y位置，可以畫出連續的直線。\n&lt;svg&gt;  &lt;polyline points=&quot;9,46 50,12 90,23 130,11 171,38 211,48 251,19&quot;&gt;&lt;/polyline&gt;&lt;/svg&gt;\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 08 Metaballs","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss08/","content":"Metaballs Demo\n  See the Pen \n  100DaysCss #08 by Cathy (@smile25896)\n  on CodePen.\n\n\n\nMetaballs是一個我覺得很神奇的題目，也因為覺得有趣稍微做了點變化和調整，成品和當初的題目其實不太一樣，其實不太知道我自己改版過後的版本還能不能叫Metaballs。以下只重點紀錄這次新學到的語法或用法。\n學習重點\nSlim\nfilter: contrast() 和 filter: blur()\n\nMetaballs中文叫做元球或變形，指兩個球體靠在一起時，會有下圖變形的情況。（圖片來源：維基百科）\nSlim這是我第一次接觸Slim，應該算是html的模板語言。有點像可以用程式邏輯的方式寫html。\n.box  - for i in (1..3)    div class&#x3D;&quot;item-#&#123; i &#125;&quot;\n\n會轉成以下html\n&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;item-1&quot;&gt;  &lt;div class=&quot;item-2&quot;&gt;  &lt;div class=&quot;item-3&quot;&gt;  &lt;div class=&quot;item-4&quot;&gt;&lt;/div&gt;\n把原本的div省略直接寫class名稱，很多重複的元素可以直接跑for迴圈非常方便，目前只用到for這個功能，以後有接觸到新功能在介紹。\nfilterfilter是css的濾鏡效果，讓Metaballs能有相黏的效果，filter是最重要的一個環節，此練習會用到filter: contrast()和filter: blur();\nfilter: blur()高斯模糊，括號李可以設定要模糊的CSS的長度。\nfilter: contrast()對比度，0就是完全沒對比（會變一片灰色）、100%表示顏色不變、超過100%對比則會越大。\n透過讓他模糊，然後再加強對比，就能達到Metaballs的效果。\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[CSS100] Day 09 Weather","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss09/","content":"Weather Demo\n  See the Pen \n  100DaysCss #08 by Cathy (@smile25896)\n  on CodePen.\n\n\n\n這次的題目不難，大致上可以分成兩個重點Sass的語法學習和雨滴動畫。雨滴的造型只要用到偽元素就能簡單達成，而雨滴降落的動畫對於我來說，更像一個數學習題，要調整雨滴降落的時間與延遲的速度，才能讓雨滴降落顯得自然。\n學習重點\nSass for迴圈\nSass @extend\n雨滴製作\n雨滴落下的動畫\n\nscss for迴圈Sass裡有迴圈的用法，如下：\n@for $i from 1 through 10 &#123;  .drop-big-#&#123;$i&#125; &#123;    left: 40 * $i + px;    animation-delay: ( random(25)/10 ) + s;    animation-duration: ( random(10)/20+0.6 ) + s;  &#125;&#125;\n\nscss @extendSass裡也有繼承的用法\n.circle &#123;  width: 10px;  height: 10px;  border-radius: 50%;  background: red;&#125;.circle-big &#123;  @extend .square  width: 30px;  height: 30px;&#125;\n轉成css會變成：\n.circle, .circle-big &#123;  width: 10px;  height: 10px;  border-radius: 50%;  background: red;&#125;.circle-big &#123;  width: 30px;  height: 30px;&#125;\n\nscss甚至可以寫成以下，也有同樣的效果\n.circle &#123;  width: 10px;  height: 10px;  border-radius: 50%;  background: red;  &amp;-big &#123;    @extend .square    width: 30px;    height: 30px;  &#125;&#125;\n\n雨滴製作雨滴是由一個圓形+三角形(before偽元素)組合成的，原本想直接讓整個雨滴透過transform: rotate()轉向。但因為雨滴落到地上時，要有一個扁掉的效果，扁掉的效果我透過transform: scale(1.5, 0.5)達成，但若整個雨滴透過transform: rotate()轉過方向，則扁掉的地方不會水平。因此，我只旋轉了三角形的部分並調整位置，達到斜斜的雨滴效果。\n$drop-color: #7FC1F9;.drop&#123;  position: absolute;  top: -10px;  left: 300px;  width: 10px;  height: 10px;  border-radius: 50%;  background: $drop-color;  animation: down 1.2s linear 0s infinite;  &amp;:before&#123;    content: &#x27;&#x27;;    display: block;    position: relative;    top: -5px;    left: 2px;    width: 0;    height: 0;    border-style: solid;    border-width: 0 5px 10px 5px;    border-color: transparent transparent $drop-color transparent;    transform: rotate(20deg);  &#125;&#125;\n\n雨滴落下的動畫讓雨滴落下的關鍵影格其實不難，可以拆解成 1.雨滴往左下方移動(0%~90%) 和 2.在最低點時扁掉(90%~100%) 這兩個部分。\n@keyframes down &#123;\t0% &#123;\t\ttransform: rotate(0deg) translate(0, 0);\t&#125;\t90% &#123;\t\ttransform: rotate(0deg) translate(-80px, 314px) scale(1, 1);\t&#125;\t100% &#123;\t\ttransform: rotate(0deg) translate(-80px, 314px) scale(1.5, 0.5);\t&#125;&#125;\n\n要讓雨滴落的自然，要靠animation-delay和animation-duration去調整，讓雨掉落的時間與速率都稍微錯開。另外一個細節就是，近的（大的）雨滴要落得比較快，遠的（小的）雨滴要落得比較慢才會自然。\n@for $i from 1 through 10 &#123;  .drop-big-#&#123;$i&#125; &#123;    animation-delay: ( random(25)/10 ) + s;    animation-duration: ( random(10)/20+0.6 ) + s;  &#125;&#125;","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[LeetCode] 1. Two Sum 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode1/","content":"前言菜鳥的刷題記錄，前端工作兩年後發現很多程式基礎（演算法、資料結構等等）都忘得差不多了，其實當初學生時期的底子也不太紮實。手很生，決定開始上 LeedCode 刷題。基本上是希望是一個紀錄菜鳥成長的過程的系列文。\n題目LeetCode 題目連結：https://leetcode.com/problems/two-sum/\n難度等級：Easy\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.\n翻譯：給一個 nums(int array)和 target(int)，找出 nums 陣列中的兩個數值加起來會等於 target，回傳這兩個元素的位置。一定會有唯一解，不會使用相同的元素兩次。\nExample 1:\nInput: nums &#x3D; [2,7,11,15], target &#x3D; 9Output: [0,1]Output: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].\n\nExample 2:\nInput: nums &#x3D; [3,2,4], target &#x3D; 6Output: [1,2]\n\nExample 3:\nInput: nums &#x3D; [3,3], target &#x3D; 6Output: [0,1]\n\n解題過程做法：很單純的跑兩個迴圈，第二個迴圈只從第一個數之後的數開始跑，若兩數相加等於零即為答案。\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123;  for (let i = 0; i &lt; nums.length; i++) &#123;    for (let j = i + 1; j &lt; nums.length; j++) &#123;      if (nums[j] + nums[i] === target) &#123;        return [i, j];      &#125;    &#125;  &#125;&#125;;\n\n成績Runtime: 76 ms (排名：83.53%)Memory Usage: 38.7 MB (排名：73.70%)\n心得LeetCode 的第一題，單純解出答案不要求效率的話，基本上沒有什麼難度，算是很溫和的試水溫題。\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 2. Add Two Numbers 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode2/","content":"題目LeetCode 題目連結：https://leetcode.com/problems/add-two-numbers/\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n輸入兩個不為空的 linked lists 代表兩個為非負數的整數，這些數字以反方向儲存，每一個 node 包含一個數字，將兩數相加，並回傳總和的 linked lists。\nExample 1:\nInput: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]Output: [7,0,8]Explanation: 342 + 465 &#x3D; 807.\n\nExample 2:\nInput: l1 &#x3D; [0], l2 &#x3D; [0]Output: [0]\n\nExample 3:\nInput: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]Output: [8,9,9,9,0,0,0,1]\n\n解題過程做法：\n將l1和l2的.val相加answers裡，溢位的部分直接將answers.next的值加1，然後將l1和l2移到.next，直到l1和l2皆等於null。\n/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function (l1, l2) &#123;  let answers = new ListNode(0);  let curNode = answers;  let isFirst = true;  while (l1 || l2) &#123;    if (!isFirst) &#123;      if (!curNode.next) &#123;        curNode.next = new ListNode(0);      &#125;      curNode = curNode.next;    &#125; else &#123;      isFirst = false;    &#125;    let sum = curNode.val;    if (l1) &#123;      sum += l1.val;      l1 = l1.next;    &#125;    if (l2) &#123;      sum += l2.val;      l2 = l2.next;    &#125;    if (sum &lt; 10) &#123;      curNode.val = sum;    &#125; else &#123;      curNode.val = sum - 10;      curNode.next = new ListNode(1);    &#125;  &#125;  return answers;&#125;;\n\n成績Runtime: 128 ms (排名：89.43%)Memory Usage: 43.8 MB (排名：85.30%)\n心得很久沒碰 linked lists 了，也沒用 javascript 寫過，一開始一直在想開頭會多一個 0，後來才想到直接回傳.next就可以跳過開頭的 0 了。\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[LeetCode] 7. Reverse Integer 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode7/","content":"題目Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n輸入一個 32-bit 的整數 x，將數字倒過來回傳。如果倒過來的數字超出[-2^31, 2^31 - 1]範圍，則回傳 0。\nExample 1:\nInput: x &#x3D; 123Output: 321\n\nExample 2:\nInput: x &#x3D; -123Output: -321\n\nExample 3:\nInput: x &#x3D; 120Output: 21\n\nExample 4:\nInput: x &#x3D; 0Output: 0\n\n解題過程方法 1基本上是把數字轉成字串，倒著因為負號不需要倒轉，先取絕對值，將 x 轉成字串再返向存入一個新的字串，如果有負號最後把負號加回去。\n/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function (x) &#123;  let xStr = String(Math.abs(x));  let ans = &quot;&quot;;  for (let i = xStr.length - 1; i &gt;= 0; i--) &#123;    ans += xStr[i];  &#125;  ans = Number(ans);  ans = x &gt; 0 ? ans : -ans;  if (ans &gt; Math.pow(2, 31) || ans &lt; -Math.pow(2, 31)) &#123;    return 0;  &#125;  return ans;&#125;;\n\n成績Runtime: 100 ms (排名：58.87%)Memory Usage: 40.5 MB (排名：35.38%)\n方法 2再思考怎麼改善的時候，突然想到或許不一定要用 string，直接用數字存也可以，於是就有了這個方法 2。\n/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function (x) &#123;  let xStr = Math.abs(x);  let ans = 0;  while (xStr &gt;= 10) &#123;    ans += xStr % 10;    ans *= 10;    xStr = parseInt(xStr / 10);  &#125;  ans += xStr;  if (x &lt; 0) &#123;    ans = -ans;  &#125;  if (ans &gt; Math.pow(2, 31) || ans &lt; -Math.pow(2, 31)) &#123;    return 0;  &#125;  return ans;&#125;;\n\n成績小小改善了一點Runtime: 100 ms (排名：58.87%)Memory Usage: 40.3 MB (排名：58.06%)\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]},{"title":"[CSS100] Day 01 Hello World","url":"/%E5%89%8D%E7%AB%AF/CSS/dayscss01/","content":"Hello World Demo\n  See the Pen \n  100DaysCss #01 by Cathy (@smile25896)\n  on CodePen.\n\n\n\nCSS 100天挑戰的第一天，因為是第一天基本上沒有什麼特別難的地方。用div畫出「100」的圖案，簡單排版下方的字，最後加上漸層背景就能完成了。本系列的文章不會手把手的詳細紀錄整個程式碼撰寫過程與說明，只會簡單筆記用到的語法與技巧。\n學習重點\n畫出「100」的字樣圖案\n線性漸層：linear-gradient\n\n畫出「100」的字樣圖案「1」斜的和豎的兩筆畫分別由兩個div組合而成的，斜的部分透過transform: rotate(50deg)讓它旋轉就能達成斜的效果，再透過絕對定位調整位置，就能組合成一個1。另外為了讓「1」看起來不那麼銳利，設定border-radius: 3px讓它有圓角。\n.one1&#123;  height: 40px;  width: 20px;  transform: rotate(50deg);  position: absolute;  top: 0;  left: -10px;&#125;.one2&#123;  height: 100px;  width: 22px;  position: absolute;  top: 0px;  left: 7px;  z-index: 3;&#125;.one1,.one2&#123;  background: #fff;  border-radius: 3px;&#125;\n\n「0」的部分是用div透過border-radius: 50%畫一個圓，中心不填色只填邊框的顏色，就可以畫成一個空心的圓。\n.zero1,.zero2&#123;  height: 100px;  width: 100px;  box-sizing: border-box;  border: 22px solid #fff;  border-radius: 50%;&#125;\n\n\n線性漸層：linear-gradient漸層其實分很多種，線性漸層、放射狀漸層等等，本次要介紹的linear-gradient是線性漸層，顧名思義就是往單一個方向直線做漸變的就叫做線性漸層。\n最簡單的寫法：\nbackground: linear-gradient(red, blue);\n\n因為沒有指定方向，預設由上到下\n\n\n若要改成從左到右可以寫成下面兩種寫法：\nbackground: linear-gradient(to right, red, blue);background: linear-gradient(90deg, red, blue);\n\n\n\n也可以調整顏色的起始位置：\nbackground: linear-gradient(90deg, red 50%, blue 100%);\n\n紅色的起始位置從50%的位置開始，所以左半邊的部分全部都是紅色，漸層的部分只從中間到右邊而已。\n\n\n想要再增加一個顏色的話，只要在參數在增加一個顏色就可以了：\nbackground: linear-gradient(90deg, red, blue, black);\n\n因為沒有設定顏色的起始位置，所以會平均分配。\n\n\n漸層的學問其實很大，除了本次介紹的線性漸層以外，css還提供了許多其他漸層的語法，可以參考深入理解 CSS 漸層 ( CSS Gradient )。\n另外漸層的色彩模式也有很多種，像是Lab、Lch、HSL、RGB，CSS原生的漸層是採用RGB的漸層方法，在顏色的過度區常常會有混濁髒髒的感覺，其實還有很多很美的漸層。詳細可以參考視覺上的完美漸層（Chromatic）這篇文章。\n\n\n","categories":["前端","CSS"],"tags":["CSS","CSS100"]},{"title":"[LeetCode] 37. Sudoku Solver 刷題筆記","url":"/%E7%A8%8B%E5%BC%8F%E8%A7%A3%E9%A1%8C/leetcode37/","content":"題目題目有點長，直接放上 LeetCode 連結：https://leetcode.com/problems/sudoku-solver/\n簡單來說就是要做一個自動產生數獨解答的程式。題目會輸入一個二維陣列，數獨題目空白的地方會用”.”代替，我們則要將數獨的答案填完回傳。\n輸入的數獨題目，一定會有一個唯一解，所以不需要考慮題目有錯誤或是多重解答的情況。\n解題過程\n從第一個空白格開始找可能的數字填上（行列和九宮格皆不重複的數字）\n再找下一個空白格找可能的數字\n如果沒有可以填的數字，則回到上一格填寫的數字，填寫下一個可能的數字。\n如果上一格已經沒有可以填寫的數字了，再回到上上格以此類推。如果有找到可以填寫的數字，則從第 2 步驟繼續往下。\n直到所有空白格都填上數字即完成。\n\n實際程式我使用遞迴的方式，如下：\nfunction solveSudoku(board) &#123;  recurse(board);  return board&#125;function recurse(board) &#123;  for(let row = 0; row &lt; 9; row++)&#123;    for(let col = 0; col &lt; 9; col++)&#123;      // 如果該格為空白，找出可能的數字填上      if(board[row][col] === &quot;.&quot;)&#123;        // 找出所有可能的數字        const possibles = Array.from(&#123;length: 9&#125;, () =&gt; true)        // 刪除相同行列出現過的數字        for(let i=0; i&lt;9; i++)&#123;          if(board[row][i] !== &quot;.&quot;)&#123;            possibles[Number(board[row][i])-1] = false;          &#125;          if(board[i][col] !== &quot;.&quot;)&#123;            possibles[Number(board[i][col])-1] = false;          &#125;        &#125;        // 刪除九宮格中出現過的數字        const blockStart = Math.floor(row/3) * 3;        const blockEnd = Math.floor(col/3) * 3;        for(let k=blockStart; k&lt;blockStart+3; k++) &#123;          for(let l=blockEnd; l&lt;blockEnd+3; l++) &#123;            if(board[k][l] !== &quot;.&quot;)&#123;              possibles[Number(board[k][l])-1] = false;            &#125;          &#125;        &#125;        // 嘗試每個可能的數字        for(let m = 0; m&lt;9; m++)&#123;          if(!possibles[m]) continue;          board[row][col] = (m+1).toString();          // 找下一個數字          if(recurse(board))&#123;            return true;          &#125;          else&#123;            board[row][col] = &quot;.&quot;;          &#125;        &#125;        // 所有數字皆不符合，return false回到上一個數字        return false;      &#125;    &#125;  &#125;  return true;&#125;\n","categories":["程式解題"],"tags":["Javascript","LeetCode"]}]